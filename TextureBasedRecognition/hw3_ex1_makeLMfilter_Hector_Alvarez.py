import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import convolve2d, convolve

def makeLMfilters(S):
    # Returns the LM filter bank of size SxSx48. Hint: Make use of meshgrid to generate its support.

    if S%2 == 0:
        S += 1

    n_filters = 48
    F = np.zeros((S, S, n_filters))

    scl_num = 3
    scl = np.linspace(1, 3, 3)
    ori_num = 6
    lap_num = 8
    gss_num = 4

    fst_der_flt = scl_num*ori_num
    snd_der_flt = scl_num*ori_num

    total_filters = fst_der_flt + snd_der_flt + lap_num + gss_num
    # S must be subtracted (-1) before division, because it is an odd number
    range_mesh = (S-1)/2
    x = np.linspace(-range_mesh, range_mesh, S)
    y = np.linspace(range_mesh, -range_mesh, S)

    xx, yy = np.meshgrid(x, y)
    xx = xx.flatten()
    yy = yy.flatten()

    my_mesh = np.array((xx, yy))

    current_flt = 0

    # Iterate through scales and orientations to generate your edge and bar filters
    # Hint: Apply a 2x2 rotation matrix to your meshgrid generated coordinates beforehand.

    for scale in scl:
        for orient in range(0, ori_num):
            angle = np.pi*orient/ori_num
            # 2x2 rotation matrix build
            c = np.cos(angle)
            s = np.sin(angle)
            rotMatrix = np.array([[c, -s], [s, c]])

            rotpts = np.matmul(rotMatrix, my_mesh)
            F[:, :, current_flt] = makefilter(scale, 1, 0, rotpts, S)
            F[:, :, current_flt + snd_der_flt] = makefilter(scale, 2, 0, rotpts, S)
            current_flt += 1

    current_flt = fst_der_flt + snd_der_flt
    scales = np.array((1, np.sqrt(2), 2, np.sqrt(2)*2))
    factor = 1

    while current_flt < total_filters:
        if current_flt < fst_der_flt + snd_der_flt + lap_num:
            #laplace = log_filt(scales[0]*factor, xx, yy)
            #F[:, :, current_flt] = normalise(np.reshape(laplace,(S,S)))
            laplace = log_filt(scales[0]*factor, x, y)
            F[:, :, current_flt] = normalise(laplace)

            laplace = log_filt(scales[1]*factor, x, y)
            F[:, :, current_flt+1] = normalise(laplace)

            laplace = log_filt(scales[2]*factor, x, y)
            F[:, :, current_flt+2] = normalise(laplace)

            laplace = log_filt(scales[3]*factor, x, y)
            F[:, :, current_flt+3] = normalise(laplace)
            current_flt += 4
            factor = 3
            s = -1
        else:
            gaussian = gauss2d(scales[s+1], x, y)
            F[:, :, current_flt] = normalise(gaussian)
            current_flt += 1
            s+=1

    return F

def makefilter(scale,orderx,ordery,pts,sup):
    # Returns 2D gaussian filter at points pts (2,N) (generated by meshgrid). 
    # Parameter scale of shape (1,2) is applied on coordinates (x,y). 
    # orderx and ordery define the derivatives [0;2] with respect to x and y. sup is the support size.

    gx = gauss1d(scale, pts[0,:], orderx)
    gy = gauss1d(scale*3, pts[1,:], ordery)
    #flt = np.multiply(gx,gy)
    flt = gx*gy
    f = normalise(np.reshape(flt,(sup, sup)))

    return f

def log_filt(sigma,x,y):
    #Return laplacian of gaussian filter at scale sigma evaluated at (x,y). Amplitude is NOT normalized.
    #Laplacian = second derivative in x + second derivative in y
    midpointx = int(x.size/2)+1
    midpointy = int(y.size/2)+1

    gaussian_x = gauss1d(sigma, x, 2)
    gx = np.zeros((x.size,x.size))
    gx[midpointx,:] = gaussian_x

    g1 = convolve2d(gx, gx.T, mode='same')

    gaussian_y = gauss1d(sigma, y, 2)
    gy = np.zeros((y.size,y.size))
    gy[:,midpointy] = gaussian_y

    g2 = convolve2d(gy, gy.T, mode='same')
    
    #gx = gauss1d(sigma, x, 2)
    #gy = gauss1d(sigma, y, 2)

    h = g1 + g2
    return h

def gauss2d(sigma,x,y):
    # Returns 2D gaussian filter at scale sigma evaluated at (x,y). Amplitude is NOT normalized.

    midpointx = int(x.size/2)+1
    midpointy = int(y.size/2)+1

    gaussian_x = gauss1d(sigma, x, 0)
    gx = np.zeros((x.size,x.size))
    gx[midpointx,:] = gaussian_x

    gaussian_y = gauss1d(sigma, y, 0)
    gy = np.zeros((y.size,y.size))
    gy[:,midpointy] = gaussian_y

    g = convolve2d(gx, gy, mode='same')
    print (g)
    return g

def gauss1d(sigma,x,order):
    #Returns 1D gaussian filter at scale sigma and order [0;2] evaluated at x.
    #Make sure that x is mean-centered.
    x = x - np.mean(x)
    num = x*x
    var = sigma**2 
    denom = 2*var 

    #Calculate order 0 values here.
    gaussian = np.exp(-num/denom)/(np.pi*denom)**0.5

    if(order == 1):
        #Derive expression on paper first. The expression should make use of order 0.
        g = -gaussian*(x/var)
    elif(order==2):
        #Derive expression on paper first. The expression should make use of order 0.
        g = gaussian*((num-var)/(var**2))
    else:
        g = gaussian
    # print (g)
    return g

def normalise(f):
    #Centers f with respect to the mean and normalize to unit (absolute) sum.
    f = f - np.mean(f)
    f_out = f/np.sum(np.abs(f))
    return f_out